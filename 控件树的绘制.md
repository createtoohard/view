# 控件树的绘制
在开发Android自定义控件时，往往都需要重写View.onDraw()方法将内容绘制到一个给定的Canvas中。

# Canvas简介
* Canvas 是一个绘图工具类，其API提供了一系列绘图指令供开发者使用。
    * 绘制指令：由一系列名为`drawxxx()`的方法提供，用来实现实际的绘制行为。
      * 示例：绘制点、线、圆、方块等
    * 辅助指令：提供辅助功能的指令将会影响后续绘制指令的效果
      * 示例：设置变化、裁剪区域等
    * Canvas 还提供了`save()`和`restore()`方法用于撤销一部分辅助指令的效果
* Canvas 根据绘制加速模式的不同可以分为 **软件Canvas** 和 **硬件Canvas**

### Canvas的绘制目标
  * **软件Canvas:** 绘制目标就是建立在Surface上的位图Bitmap。
    * 通过`Surface.lockCanvas()`方法获得一个Canvas时会以Surface的内存创建一个Bbitmap，通过Canvas所绘制的内容会直接反映到Surface中
  * **硬件Canvas:** 绘制目标有两种。
    * **HardwareLayer:** GL Texture(纹理)，可以理解为硬件加速下的位图（Bitmap）
    * **DisplayList:** DisplayList不是一块Buffer,而是一个指令序列。DisplayList会将Canvas的绘制指令编译并优化为硬件绘制指令，并且可以在需要的时候将这些指令放回到一个HardwareLayer上。
  * DisplayList、Bitmap、HardwareLayer都可以理解为Canvas的画布


### Canvas的辅助指令
#### 1. 坐标变换
* `Canvas.translate()` 方法
  * 该方法即坐标变换指令，将矩形的位置和尺寸信息进行了分离，使得绘制矩形时的参数得到简化    

* 示例：当需要在（100,200）的位置绘制一个宽为50、高为100的矩形时。
  * 示例实现1（不使用辅助指令---坐标变换）
  ```java
  float x=100f, y=200f, w=50f, h=100f;
  mCanvas.drawRect(x, y, x+w, y+h, mPaint);
  ```

  * 示例实现2（坐标变换）
  ```java
  float x=100f, y=200f, w=50f, h=100f;
  //先使用translate()方法将后续绘制的坐标系原点变换到（x,y）的位置
  mCanvas.translate(x, y);
  //在新的坐标系下绘制矩形
  mCanvas.drawRect(0, 0, w, h, mPaint);
  ```


# 控件的脏区域
* 为来保证绘制的效率，控件树仅仅对需要重绘的区域进行绘制，这部分需要重绘的区域称为“脏区域”（DirtyArea）
* 当控件的内容发生变化需要重绘时，会调用`View.invalidate()`方法将需要重绘的区域沿着控件树提交给`ViewRootImpl`,并保存在`ViewRootImpl.mDiryt`全局变量中。
* 通过`scheduleTraversals()`方法引发一次遍历，使得`ViewRootImpl.mDirty`所描绘的区域得到重绘，避免不必要的开销
* `View.invalidate()`方法在回溯到`ViewRootImpl`的过程中会将沿途的控件标记为脏的，即将`View.mPrivateFlags`全局变量中添加`PFLAG_DIRTY`或`PFLAG_DIRTY_OPAQUE`。即有这两种标记的控件随后需要重绘。
  * `View.isOpaque()`方法，用于判断该控件是否为实心控件，（实心控件表示绘制内容会覆盖整个区域，无法看到该区域下的内容）
    * 如果是实心控件，标记为`PFLAG_DIRTY_OPAQUE`
      * 该标记的控件可以跳过背景绘制，反正也看不见
    * 非实心控件，标记为`PFLAG_DIRTY`
* 多次调用`invalidate()`方法会使得`ViewRootImpl`多次接收到脏区域的请求，`ViewRootImpl`会将这些脏区域累加到`mDirty`中，在随后的遍历种一次性地完成所有脏区域的重绘。
* `ViewRootImpl.mFullRedrawNeeded`为true时（窗口第一次绘制、或者窗口发生变化时）会使得在绘制之前将`mDirty`所描述的区域扩大到整个窗口，进而实现完整的重绘。


# 控件树绘制
在`ViewRootImpl.performTraversal()`的最后阶段调用了`ViewRootImpl.performDraw()`方法，该方法是绘制控件树的入口。

## 控件树绘制时序图
```puml
Title : 控件树绘制
ViewRootImpl -> ViewRootImpl : performDraw()
ViewRootImpl -> ViewRootImpl : draw()
Note right of ViewRootImpl : 硬件绘制
ViewRootImpl -> ThreadedRenderer : draw()

Note right of ViewRootImpl : 软件绘制
ViewRootImpl -> ViewRootImpl : drawSoftware()
ViewRootImpl -> Surface : lockCanvas()
Surface -> ViewRootImpl : 返回一个Canvas对象
ViewRootImpl -> Canvas : translate()
ViewRootImpl -> View : draw()
ViewRootImpl -> Surface : unlockCanvasAndPost()



```

## `ViewRootImpl.performDraw()`方法
```java
private void performDraw() {
    //......
    final boolean fullRedrawNeeded = mFullRedrawNeeded;
    mFullRedrawNeeded = false;

    mIsDrawing = true;
    try {
        //调用ViewRootImpl.draw()方法进行实际的绘制工作
        draw(fullRedrawNeeded);
    } finally {
        mIsDrawing = false;
    }
    //......
    if (mReportNextDraw) {
        mReportNextDraw = false;
        //.......
        try {
            //通知WMS绘制已经完成
            mWindowSession.finishDrawing(mWindow);
        } catch (RemoteException e) {
        }
    }
}
```

## `ViewRootImpl.draw()`方法
```java
private void draw(boolean fullRedrawNeeded) {
    Surface surface = mSurface;
    //......

    /*计算mView在垂直方向的滚动量（ScrollY）
    在VisibleInsets存在的情况下，ViewRootImpl需要保证某个关键的控件是可见的

    例如当输入法弹出时，接收输入的TextView必须位于不被输入法遮挡的区域内，如果布局结果
    被挡，就需要根据VisibleInsets和它的相对位置计算一个滚动量，使整个控件树的绘制位置
    发生偏移，从而使TextView露出来。

    计算得到的滚动量被保存在mScroller中
    */
    scrollToRectOrFocus(null, false);

    if (mAttachInfo.mViewScrollChanged) {
        mAttachInfo.mViewScrollChanged = false;
        mAttachInfo.mTreeObserver.dispatchOnScrollChanged();
    }

    //为了滚动显得不那么突兀，产生一个动画效果
    boolean animating = mScroller != null && mScroller.computeScrollOffset();
    final int curScrollY;
    if (animating) {//动画正在执行，采用mScroller所计算的滚动量
        curScrollY = mScroller.getCurrY();
    } else {//动画已经结束，使用scrollToRectOrFocus()计算的滚动量
        curScrollY = mScrollY;
    }
    //如果新计算的滚动量与上次绘制的滚动量不同，则必须进行完整的绘制
    //因为发生滚动时，整个画面都需要更新，设置fullRedrawNeeded为true
    if (mCurScrollY != curScrollY) {
        mCurScrollY = curScrollY;
        fullRedrawNeeded = true;
        //如果view需要自己渲染，则将滚动量回调给它
        if (mView instanceof RootViewSurfaceTaker) {
            ((RootViewSurfaceTaker) mView).onRootViewScrollYChanged(mCurScrollY);
        }
    }
    //......
    //需要全部更新，重新设置dirty区域为整个窗口
    if (fullRedrawNeeded) {
        mAttachInfo.mIgnoreDirtyState = true;
        dirty.set(0, 0, (int) (mWidth * appScale + 0.5f), (int) (mHeight * appScale + 0.5f));
    }
    //......
    if (!dirty.isEmpty() || mIsAnimating || accessibilityFocusDirty) {
        //硬件加速渲染是打开且有效的
        if (mAttachInfo.mHardwareRenderer != null && mAttachInfo.mHardwareRenderer.isEnabled()) {
            //......
            //通过硬件加速绘制调用ThreadedRenderer.draw()方法
            mAttachInfo.mHardwareRenderer.draw(mView, mAttachInfo, this);
        } else {//没有硬件加速
            //硬件加速绘制存在且请求过，但是没有打开，尝试重新初始化,重新遍历全部更新
            //......
            //调用drawSoftware()方法进行软件绘制
            if (!drawSoftware(surface, mAttachInfo, xOffset, yOffset, scalingRequired, dirty)) {
                return;
            }
        }
    }

    //如果mScroller仍然在动画过程中，则立即安排下一次重绘，
    if (animating) {
        //设置mFullRedrawNeeded为true，表示整个窗口需要全部更新
        mFullRedrawNeeded = true;
        //调用scheduleTraversals()遍历
        scheduleTraversals();
    }
}
```

## 软件绘制
1. 调用`Surface.lockCanvas()`方法获取一个用于绘制的`Canvas`
2. 调用`Canvas.translate()`方法将坐标系切换到控件自身的坐标系
3. 调用`View.draw()`方法将根控件绘制在Canvas上
4. 调用`Surface.unlockCanvasAndPost()`方法显示绘制后的内容

### `ViewRootImpl.drawSoftware()`方法
```java
private boolean drawSoftware(Surface surface, AttachInfo attachInfo, int xoff, int yoff,
        boolean scalingRequired, Rect dirty) {
    //定义绘制所需要的Canvas
    final Canvas canvas;
    try {
        //初始化脏区域的点坐标
        final int left = dirty.left;
        final int top = dirty.top;``
        final int right = dirty.right;
        final int bottom = dirty.bottom;
        //通过Surface.lockCanvas()方法获取一个以此surface为画布的Canvas
        canvas = mSurface.lockCanvas(dirty);

        // lockCanvas可能会改变脏区域大小，所以这里判断一下
        if (left != dirty.left || top != dirty.top || right != dirty.right
                || bottom != dirty.bottom) {
            attachInfo.mIgnoreDirtyState = true;
        }
        //设置Bitmap密度
        canvas.setDensity(mDensity);
    } catch (Surface.OutOfResourcesException e) {
        handleOutOfResourcesException(e);
        return false;
    } catch (IllegalArgumentException e) {
        //通知wm下次给个新的surface
        mLayoutRequested = true;
        return false;
    }

    try {
        //如果Bitmap有设置alpha的途径，需要清除
        if (!canvas.isOpaque() || yoff != 0 || xoff != 0) {
            canvas.drawColor(0, PorterDuff.Mode.CLEAR);
        }

        //绘制之前清空脏区域，这样如果在绘制过程中调用了View.invalidate()方法，可以重新计算脏区域
        dirty.setEmpty();
        mIsAnimating = false;
        mView.mPrivateFlags |= View.PFLAG_DRAWN;

        try {
            //使用Canvas进行第一次变换
            //变换的目的是使得其坐标系按照之前所计算的滚动量进行相应的滚动
            //随后绘制的内容都会在滚动后的新坐标系下进行
            canvas.translate(-xoff, -yoff);
            if (mTranslator != null) {
                mTranslator.translateCanvas(canvas);
            }
            //设置屏幕密度
            canvas.setScreenDensity(scalingRequired ? mNoncompatDensity : 0);
            attachInfo.mSetIgnoreDirtyState = false;
            //调用View.draw()方法在Canvas上绘制整个控件树
            mView.draw(canvas);

            drawAccessibilityFocusedDrawableIfNeeded(canvas);
        } finally {
            if (!attachInfo.mSetIgnoreDirtyState) {
                attachInfo.mIgnoreDirtyState = false;
            }
        }
    } finally {
        try {
            //调用Surface.unlockCanvasAndPost()方法显示绘制后的内容
            surface.unlockCanvasAndPost(canvas);
        } catch (IllegalArgumentException e) {
            mLayoutRequested = true;    // ask wm for a new surface next time.
            return false;
        }
    }
    return true;
}
```

### `View.draw()` 方法
绘制控件树
```java
public void draw(Canvas canvas) {
    final int privateFlags = mPrivateFlags;
    //
    final boolean dirtyOpaque = (privateFlags & PFLAG_DIRTY_MASK) == PFLAG_DIRTY_OPAQUE &&
            (mAttachInfo == null || !mAttachInfo.mIgnoreDirtyState);
    mPrivateFlags = (privateFlags & ~PFLAG_DIRTY_MASK) | PFLAG_DRAWN;

    /*
     * Draw traversal performs several drawing steps which must be executed
     * in the appropriate order:
     *
     *      1. Draw the background
     *      2. If necessary, save the canvas' layers to prepare for fading
     *      3. Draw view's content
     *      4. Draw children
     *      5. If necessary, draw the fading edges and restore layers
     *      6. Draw decorations (scrollbars for instance)
     */

    // Step 1, draw the background, if needed
    int saveCount;

    if (!dirtyOpaque) {
        drawBackground(canvas);
    }

    // skip step 2 & 5 if possible (common case)
    final int viewFlags = mViewFlags;
    boolean horizontalEdges = (viewFlags & FADING_EDGE_HORIZONTAL) != 0;
    boolean verticalEdges = (viewFlags & FADING_EDGE_VERTICAL) != 0;
    if (!verticalEdges && !horizontalEdges) {
        // Step 3, draw the content
        if (!dirtyOpaque) onDraw(canvas);

        // Step 4, draw the children
        dispatchDraw(canvas);

        // Overlay is part of the content and draws beneath Foreground
        if (mOverlay != null && !mOverlay.isEmpty()) {
            mOverlay.getOverlayView().dispatchDraw(canvas);
        }

        // Step 6, draw decorations (foreground, scrollbars)
        onDrawForeground(canvas);

        // we're done...
        return;
    }

    /*
     * Here we do the full fledged routine...
     * (this is an uncommon case where speed matters less,
     * this is why we repeat some of the tests that have been
     * done above)
     */

    boolean drawTop = false;
    boolean drawBottom = false;
    boolean drawLeft = false;
    boolean drawRight = false;

    float topFadeStrength = 0.0f;
    float bottomFadeStrength = 0.0f;
    float leftFadeStrength = 0.0f;
    float rightFadeStrength = 0.0f;

    // Step 2, save the canvas' layers
    int paddingLeft = mPaddingLeft;

    final boolean offsetRequired = isPaddingOffsetRequired();
    if (offsetRequired) {
        paddingLeft += getLeftPaddingOffset();
    }

    int left = mScrollX + paddingLeft;
    int right = left + mRight - mLeft - mPaddingRight - paddingLeft;
    int top = mScrollY + getFadeTop(offsetRequired);
    int bottom = top + getFadeHeight(offsetRequired);

    if (offsetRequired) {
        right += getRightPaddingOffset();
        bottom += getBottomPaddingOffset();
    }

    final ScrollabilityCache scrollabilityCache = mScrollCache;
    final float fadeHeight = scrollabilityCache.fadingEdgeLength;
    int length = (int) fadeHeight;

    // clip the fade length if top and bottom fades overlap
    // overlapping fades produce odd-looking artifacts
    if (verticalEdges && (top + length > bottom - length)) {
        length = (bottom - top) / 2;
    }

    // also clip horizontal fades if necessary
    if (horizontalEdges && (left + length > right - length)) {
        length = (right - left) / 2;
    }

    if (verticalEdges) {
        topFadeStrength = Math.max(0.0f, Math.min(1.0f, getTopFadingEdgeStrength()));
        drawTop = topFadeStrength * fadeHeight > 1.0f;
        bottomFadeStrength = Math.max(0.0f, Math.min(1.0f, getBottomFadingEdgeStrength()));
        drawBottom = bottomFadeStrength * fadeHeight > 1.0f;
    }

    if (horizontalEdges) {
        leftFadeStrength = Math.max(0.0f, Math.min(1.0f, getLeftFadingEdgeStrength()));
        drawLeft = leftFadeStrength * fadeHeight > 1.0f;
        rightFadeStrength = Math.max(0.0f, Math.min(1.0f, getRightFadingEdgeStrength()));
        drawRight = rightFadeStrength * fadeHeight > 1.0f;
    }

    saveCount = canvas.getSaveCount();

    int solidColor = getSolidColor();
    if (solidColor == 0) {
        final int flags = Canvas.HAS_ALPHA_LAYER_SAVE_FLAG;

        if (drawTop) {
            canvas.saveLayer(left, top, right, top + length, null, flags);
        }

        if (drawBottom) {
            canvas.saveLayer(left, bottom - length, right, bottom, null, flags);
        }

        if (drawLeft) {
            canvas.saveLayer(left, top, left + length, bottom, null, flags);
        }

        if (drawRight) {
            canvas.saveLayer(right - length, top, right, bottom, null, flags);
        }
    } else {
        scrollabilityCache.setFadeColor(solidColor);
    }

    // Step 3, draw the content
    if (!dirtyOpaque) onDraw(canvas);

    // Step 4, draw the children
    dispatchDraw(canvas);

    // Step 5, draw the fade effect and restore layers
    final Paint p = scrollabilityCache.paint;
    final Matrix matrix = scrollabilityCache.matrix;
    final Shader fade = scrollabilityCache.shader;

    if (drawTop) {
        matrix.setScale(1, fadeHeight * topFadeStrength);
        matrix.postTranslate(left, top);
        fade.setLocalMatrix(matrix);
        p.setShader(fade);
        canvas.drawRect(left, top, right, top + length, p);
    }

    if (drawBottom) {
        matrix.setScale(1, fadeHeight * bottomFadeStrength);
        matrix.postRotate(180);
        matrix.postTranslate(left, bottom);
        fade.setLocalMatrix(matrix);
        p.setShader(fade);
        canvas.drawRect(left, bottom - length, right, bottom, p);
    }

    if (drawLeft) {
        matrix.setScale(1, fadeHeight * leftFadeStrength);
        matrix.postRotate(-90);
        matrix.postTranslate(left, top);
        fade.setLocalMatrix(matrix);
        p.setShader(fade);
        canvas.drawRect(left, top, left + length, bottom, p);
    }

    if (drawRight) {
        matrix.setScale(1, fadeHeight * rightFadeStrength);
        matrix.postRotate(90);
        matrix.postTranslate(right, top);
        fade.setLocalMatrix(matrix);
        p.setShader(fade);
        canvas.drawRect(right - length, top, right, bottom, p);
    }

    canvas.restoreToCount(saveCount);

    // Overlay is part of the content and draws beneath Foreground
    if (mOverlay != null && !mOverlay.isEmpty()) {
        mOverlay.getOverlayView().dispatchDraw(canvas);
    }

    // Step 6, draw decorations (foreground, scrollbars)
    onDrawForeground(canvas);
}
```
