# 控件树的绘制
在开发Android自定义控件时，往往都需要重写View.onDraw()方法将内容绘制到一个给定的Canvas中。

# Canvas简介
* Canvas 是一个绘图工具类，其API提供了一系列绘图指令供开发者使用。
    * 绘制指令：由一系列名为`drawxxx()`的方法提供，用来实现实际的绘制行为。
      * 示例：绘制点、线、圆、方块等
    * 辅助指令：提供辅助功能的指令将会影响后续绘制指令的效果
      * 示例：设置变化、裁剪区域等
    * Canvas 还提供了`save()`和`restore()`方法用于撤销一部分辅助指令的效果
* Canvas 根据绘制加速模式的不同可以分为 **软件Canvas** 和 **硬件Canvas**

### Canvas的绘制目标
  * **软件Canvas:** 绘制目标就是建立在Surface上的位图Bitmap。
    * 通过`Surface.lockCanvas()`方法获得一个Canvas时会以Surface的内存创建一个Bbitmap，通过Canvas所绘制的内容会直接反映到Surface中
  * **硬件Canvas:** 绘制目标有两种。
    * **HardwareLayer:** GL Texture(纹理)，可以理解为硬件加速下的位图（Bitmap）
    * **DisplayList:** DisplayList不是一块Buffer,而是一个指令序列。DisplayList会将Canvas的绘制指令编译并优化为硬件绘制指令，并且可以在需要的时候将这些指令放回到一个HardwareLayer上。
  * DisplayList、Bitmap、HardwareLayer都可以理解为Canvas的画布


### Canvas的辅助指令
#### 1. 坐标变换
* `Canvas.translate()` 方法
  * 该方法即坐标变换指令，将矩形的位置和尺寸信息进行了分离，使得绘制矩形时的参数得到简化    

* 示例：当需要在（100,200）的位置绘制一个宽为50、高为100的矩形时。
  * 示例实现1（不使用辅助指令---坐标变换）
  ```java
  float x=100f, y=200f, w=50f, h=100f;
  mCanvas.drawRect(x, y, x+w, y+h, mPaint);
  ```

  * 示例实现2（坐标变换）
  ```java
  float x=100f, y=200f, w=50f, h=100f;
  //先使用translate()方法将后续绘制的坐标系原点变换到（x,y）的位置
  mCanvas.translate(x, y);
  //在新的坐标系下绘制矩形
  mCanvas.drawRect(0, 0, w, h, mPaint);
  ```


# 控件的脏区域
* 为来保证绘制的效率，控件树仅仅对需要重绘的区域进行绘制，这部分需要重绘的区域称为“脏区域”（DirtyArea）
* 当控件的内容发生变化需要重绘时，会调用`View.invalidate()`方法将需要重绘的区域沿着控件树提交给`ViewRootImpl`,并保存在`ViewRootImpl.mDiryt`全局变量中。
* 通过`scheduleTraversals()`方法引发一次遍历，使得`ViewRootImpl.mDirty`所描绘的区域得到重绘，避免不必要的开销
* `View.invalidate()`方法在回溯到`ViewRootImpl`的过程中会将沿途的控件标记为脏的，即将`View.mPrivateFlags`全局变量中添加`PFLAG_DIRTY`或`PFLAG_DIRTY_OPAQUE`。即有这两种标记的控件随后需要重绘。
  * `View.isOpaque()`方法，用于判断该控件是否为实心控件，（实心控件表示绘制内容会覆盖整个区域，无法看到该区域下的内容）
    * 如果是实心控件，标记为`PFLAG_DIRTY_OPAQUE`
      * 该标记的控件可以跳过背景绘制，反正也看不见
    * 非实心控件，标记为`PFLAG_DIRTY`
* 多次调用`invalidate()`方法会使得`ViewRootImpl`多次接收到脏区域的请求，`ViewRootImpl`会将这些脏区域累加到`mDirty`中，在随后的遍历种一次性地完成所有脏区域的重绘。
* `ViewRootImpl.mFullRedrawNeeded`为true时（窗口第一次绘制、或者窗口发生变化时）会使得在绘制之前将`mDirty`所描述的区域扩大到整个窗口，进而实现完整的重绘。


# 控件树绘制
在`ViewRootImpl.performTraversal()`的最后阶段调用了`ViewRootImpl.performDraw()`方法，该方法是绘制控件树的入口。

## 控件树绘制时序图
```puml
Title : 控件树绘制
ViewRootImpl -> ViewRootImpl : performDraw()
ViewRootImpl -> ViewRootImpl : draw()


Note right of ViewRootImpl : 硬件绘制
ViewRootImpl -> ThreadedRenderer : draw()
ThreadedRenderer -> ThreadedRenderer : updateRootDisplayList()
ThreadedRenderer -> ThreadedRenderer : updateViewTreeDisplayList()

ThreadedRenderer -> View : updateDisplayListIfDirty()
View -> RenderNode : start()
RenderNode -> View : 返回DisplayListCanvas对象
Note right of View : 控件树绘制流程
View -> View : draw()
View -> RenderNode : end()

ThreadedRenderer -> RenderNode : start()
RenderNode -> ThreadedRenderer : 返回DisplayListCanvas对象
ThreadedRenderer -> DisplayListCanvas : drawRenderNode()
DisplayListCanvas -> RenderNode : getNativeDisplayList()
DisplayListCanvas -> JNI : nDrawRenderNode()
ThreadedRenderer -> RenderNode : end()


ThreadedRenderer -> JNI : nSyncAndDrawFrame()

Note right of ViewRootImpl : 软件绘制
ViewRootImpl -> ViewRootImpl : drawSoftware()
ViewRootImpl -> Surface : lockCanvas()
Surface -> ViewRootImpl : 返回一个Canvas对象
ViewRootImpl -> Canvas : translate()
ViewRootImpl -> View : draw()
Note right of View : 控件绘制流程
View -> View : 1. drawBackground()
View -> Canvas : 2. saveLayer()
View -> View : 3. onDraw()
View -> ViewGroup : 4. dispatchDraw()
ViewGroup -> ViewGroup : drawChild()
ViewGroup -> View : draw()
View -> Canvas : 5. drawRect() & restoreToCount()
View -> View : 6. onDrawForeground()

ViewRootImpl -> Surface : unlockCanvasAndPost()



```

## `ViewRootImpl.performDraw()`方法
```java
private void performDraw() {
    //......
    final boolean fullRedrawNeeded = mFullRedrawNeeded;
    mFullRedrawNeeded = false;

    mIsDrawing = true;
    try {
        //调用ViewRootImpl.draw()方法进行实际的绘制工作
        draw(fullRedrawNeeded);
    } finally {
        mIsDrawing = false;
    }
    //......
    if (mReportNextDraw) {
        mReportNextDraw = false;
        //.......
        try {
            //通知WMS绘制已经完成
            mWindowSession.finishDrawing(mWindow);
        } catch (RemoteException e) {
        }
    }
}
```

## `ViewRootImpl.draw()`方法
```java
private void draw(boolean fullRedrawNeeded) {
    Surface surface = mSurface;
    //......

    /*计算mView在垂直方向的滚动量（ScrollY）
    在VisibleInsets存在的情况下，ViewRootImpl需要保证某个关键的控件是可见的

    例如当输入法弹出时，接收输入的TextView必须位于不被输入法遮挡的区域内，如果布局结果
    被挡，就需要根据VisibleInsets和它的相对位置计算一个滚动量，使整个控件树的绘制位置
    发生偏移，从而使TextView露出来。

    计算得到的滚动量被保存在mScroller中
    */
    scrollToRectOrFocus(null, false);

    if (mAttachInfo.mViewScrollChanged) {
        mAttachInfo.mViewScrollChanged = false;
        mAttachInfo.mTreeObserver.dispatchOnScrollChanged();
    }

    //为了滚动显得不那么突兀，产生一个动画效果
    boolean animating = mScroller != null && mScroller.computeScrollOffset();
    final int curScrollY;
    if (animating) {//动画正在执行，采用mScroller所计算的滚动量
        curScrollY = mScroller.getCurrY();
    } else {//动画已经结束，使用scrollToRectOrFocus()计算的滚动量
        curScrollY = mScrollY;
    }
    //如果新计算的滚动量与上次绘制的滚动量不同，则必须进行完整的绘制
    //因为发生滚动时，整个画面都需要更新，设置fullRedrawNeeded为true
    if (mCurScrollY != curScrollY) {
        mCurScrollY = curScrollY;
        fullRedrawNeeded = true;
        //如果view需要自己渲染，则将滚动量回调给它
        if (mView instanceo对象f RootViewSurfaceTaker) {
            ((RootViewSurfaceTaker) mView).onRootViewScrollYChanged(mCurScrollY);
        }
    }
    //......
    //需要全部更新，重新设置dirty区域为整个窗口
    if (fullRedrawNeeded) {
        mAttachInfo.mIgnoreDirtyState = true;
        dirty.set(0, 0, (int) (mWidth * appScale + 0.5f), (int) (mHeight * appScale + 0.5f));
    }
    //......
    if (!dirty.isEmpty() || mIsAnimating || accessibilityFocusDirty) {
        //硬件加速渲染是打开且有效的
        if (mAttachInfo.mHardwareRenderer != null && mAttachInfo.mHardwareRenderer.isEnabled()) {
            //......
            //通过硬件加速绘制调用ThreadedRenderer.draw()方法
            mAttachInfo.mHardwareRenderer.draw(mView, mAttachInfo, this);
        } else {//没有硬件加速
            //硬件加速绘制存在且请求过，但是没有打开，尝试重新初始化,重新遍历全部更新
            //......
            //调用drawSoftware()方法进行软件绘制
            if (!drawSoftware(surface, mAttachInfo, xOffset, yOffset, scalingRequired, dirty)) {
                return;
            }
        }
    }

    //如果mScroller仍然在动画过程中，则立即安排下一次重绘，
    if (animating) {
        //设置mFullRedrawNeeded为true，表示整个窗口需要全部更新
        mFullRedrawNeeded = true;
        //调用scheduleTraversals()遍历
        scheduleTraversals();
    }
}
```


---
## 硬件绘制
* 相对于软件绘制，硬件加速绘制可以充分利用GPU的性能，极大地提高了绘制效率
### `ThreadedRenderer.draw()`方法
```java
void draw(View view, AttachInfo attachInfo, HardwareDrawCallbacks callbacks) {
    attachInfo.mIgnoreDirtyState = true;

    final Choreographer choreographer = attachInfo.mViewRootImpl.mChoreographer;
    choreographer.mFrameInfo.markDrawStart();
    //调用updateRootDisplayList()方法，构建根控件的DisplayList
    updateRootDisplayList(view, callbacks);

    attachInfo.mIgnoreDirtyState = false;

    //......动画相关
    final long[] frameInfo = choreographer.mFrameInfo.mFrameInfo;
    //调用jni层的nSyncAndDrawFrame()方法，通知RenderThread绘制下一帧
    int syncResult = nSyncAndDrawFrame(mNativeProxy, frameInfo, frameInfo.length);
    if ((syncResult & SYNC_LOST_SURFACE_REWARD_IF_FOUND) != 0) {
        setEnabled(false);
        attachInfo.mViewRootImpl.mSurface.release();
        attachInfo.mViewRootImpl.invalidate();
    }
    if ((syncResult & SYNC_INVALIDATE_REQUIRED) != 0) {
        attachInfo.mViewRootImpl.invalidate();
    }
}
```

### `ThreadedRenderer.updateRootDisplayList()` 方法
* 构建DecorView的DisplayList
* 设置Barrier是为了将一个view的所有的Draw Op及其子view对应的Draw op记录在一个chunk中
```java
private void updateRootDisplayList(View view, HardwareDrawCallbacks callbacks) {
    //调用updateViewTreeDisplayList()方法，构建参数view描述的视图的DisplayList，即DecorView的DisplayList
    updateViewTreeDisplayList(view);
    //mRootNodeNeedsUpdate为true或者mRootNode还未构建，表示要更新mRootNode的DisplayList
    if (mRootNodeNeedsUpdate || !mRootNode.isValid()) {
        //调用RenderNode.start()方法获得一个HardwareCanvas
        DisplayListCanvas canvas = mRootNode.start(mSurfaceWidth, mSurfaceHeight);
        try {
            final int saveCount = canvas.save();
            canvas.translate(mInsetLeft, mInsetTop);
            callbacks.onHardwarePreDraw(canvas);
            //调用HardwareCanvas.insertReorderBarrier()方法，设置一个ReorderBarrier
            canvas.insertReorderBarrier();
            //调用HardwareCanvas.drawRenderNode()方法将view的DisplayList绘制在里面
            canvas.drawRenderNode(view.updateDisplayListIfDirty());
            //调用HardwareCanvas.insertInorderBarrier()方法，设置一个InorderBarrier
            canvas.insertInorderBarrier();

            callbacks.onHardwarePostDraw(canvas);
            canvas.restoreToCount(saveCount);
            mRootNodeNeedsUpdate = false;
        } finally {
            //调用RootRender.end()方法，取出已经绘制好的HardwareCanvas的数据，并且作为RenderNode的新的DisplayList
            mRootNode.end(canvas);
        }
    }
}
```


### `ThreadedRenderer.updateViewTreeDisplayList()` 方法
* 构建DecorView的DisplayList
```java
private void updateViewTreeDisplayList(View view) {
    view.mPrivateFlags |= View.PFLAG_DRAWN;
    view.mRecreateDisplayList = (view.mPrivateFlags & View.PFLAG_INVALIDATED)
            == View.PFLAG_INVALIDATED;
    view.mPrivateFlags &= ~View.PFLAG_INVALIDATED;
    //调用View.updateDisplayListIfDirty()方法
    view.updateDisplayListIfDirty();
    view.mRecreateDisplayList = false;
}
```

### `View.updateDisplayListIfDirty()` 方法
```java
public RenderNode updateDisplayListIfDirty() {
    final RenderNode renderNode = mRenderNode;
    if (!canHaveDisplayList()) {
        // can't populate RenderNode, don't try
        return renderNode;
    }

    if ((mPrivateFlags & PFLAG_DRAWING_CACHE_VALID) == 0
            || !renderNode.isValid()
            || (mRecreateDisplayList)) {
        // Don't need to recreate the display list, just need to tell our
        // children to restore/recreate theirs
        if (renderNode.isValid()
                && !mRecreateDisplayList) {
            mPrivateFlags |= PFLAG_DRAWN | PFLAG_DRAWING_CACHE_VALID;
            mPrivateFlags &= ~PFLAG_DIRTY_MASK;
            dispatchGetDisplayList();

            return renderNode; // no work needed
        }

        // If we got here, we're recreating it. Mark it as such to ensure that
        // we copy in child display lists into ours in drawChild()
        mRecreateDisplayList = true;

        int width = mRight - mLeft;
        int height = mBottom - mTop;
        int layerType = getLayerType();

        //调用RenderNode.start()方法获取一个DisplayListCanvas对象
        final DisplayListCanvas canvas = renderNode.start(width, height);
        canvas.setHighContrastText(mAttachInfo.mHighContrastText);

        try {
            if (layerType == LAYER_TYPE_SOFTWARE) {
                buildDrawingCache(true);
                Bitmap cache = getDrawingCache(true);
                if (cache != null) {
                    canvas.drawBitmap(cache, 0, 0, mLayerPaint);
                }
            } else {
                computeScroll();

                canvas.translate(-mScrollX, -mScrollY);
                mPrivateFlags |= PFLAG_DRAWN | PFLAG_DRAWING_CACHE_VALID;
                mPrivateFlags &= ~PFLAG_DIRTY_MASK;

                // 没有背景，快速绘制
                if ((mPrivateFlags & PFLAG_SKIP_DRAW) == PFLAG_SKIP_DRAW) {
                    dispatchDraw(canvas);
                    if (mOverlay != null && !mOverlay.isEmpty()) {
                        mOverlay.getOverlayView().draw(canvas);
                    }
                } else {
                    //调用draw()方法进行绘制
                    draw(canvas);
                }
            }
        } finally {
            renderNode.end(canvas);
            setDisplayListProperties(renderNode);
        }
    } else {
        mPrivateFlags |= PFLAG_DRAWN | PFLAG_DRAWING_CACHE_VALID;
        mPrivateFlags &= ~PFLAG_DIRTY_MASK;
    }
    return renderNode;
}
```


### `RenderNode.start()` 方法
* 获取DisplayListCanvas对象
* 调用到Native层创建一个DisplayListCanvas对象
* 并将Native层DisplayListCanvas对象地址保存到Canvas对象的mNativeCanvasWrapper全局变量中
```java
public DisplayListCanvas start(int width, int height) {
    //调用DisplayListCanvas.obtain()方法，返回一个DisplayListCanvas对象
    return DisplayListCanvas.obtain(this, width, height);
}
```

#### `DisplayListCanvas.obtain()` 方法
```java
static DisplayListCanvas obtain(@NonNull RenderNode node, int width, int height) {
    if (node == null) throw new IllegalArgumentException("node cannot be null");
    //从sPool种申请一个DisplayListCanvas，如果没有就新建一个
    DisplayListCanvas canvas = sPool.acquire();
    if (canvas == null) {
        canvas = new DisplayListCanvas(width, height);
    } else {
        nResetDisplayListCanvas(canvas.mNativeCanvasWrapper, width, height);
    }
    //将RenderNode参数保存到.mNode中。这里的宽高是Surface的宽高
    canvas.mNode = node;
    canvas.mWidth = width;
    canvas.mHeight = height;
    return canvas;
}
```

#### `DisplayListCanvas.DisplayListCanvas()` 构造函数
```java
private DisplayListCanvas(int width, int height) {
    //调用natvie层的nCreateDisplayListCanvas()函数，并将返回值作为参数调用Canvas的对应的构造函数
    super(nCreateDisplayListCanvas(width, height));
    mDensity = 0; // disable bitmap density scaling
}
```

#### `createDisplayListCanvas()` 函数
```cpp
static jlong android_view_DisplayListCanvas_createDisplayListCanvas(JNIEnv* env, jobject clazz,
        jint width, jint height) {
    return reinterpret_cast<jlong>(Canvas::create_recording_canvas(width, height));
}
```

#### `Canvas::create_recording_canvas()` 函数
创建一个对象并将地址返回
```cpp
Canvas* Canvas::create_recording_canvas(int width, int height) {
#if HWUI_NEW_OPS
    return new uirenderer::RecordingCanvas(width, height);
#else
    return new uirenderer::DisplayListCanvas(width, height);
#endif
}
```

#### `Canvas.Canvas()` 构造函数
```java
public Canvas(long nativeCanvas) {
    if (nativeCanvas == 0) {
        throw new IllegalStateException();
    }
    mNativeCanvasWrapper = nativeCanvas;
    mFinalizer = NoImagePreloadHolder.sRegistry.registerNativeAllocation(
            this, mNativeCanvasWrapper);
    mDensity = Bitmap.getDefaultDensity();
}
```


### `DisplayListCanvas.drawRenderNode()` 方法
* 将DisplayList绘制到RenderNode
```java
public void drawRenderNode(RenderNode renderNode) {
    //调用jni层的nDrawRenderNode()函数，mNativeCanvasWrapper即native层Canvas的地址
    nDrawRenderNode(mNativeCanvasWrapper, renderNode.getNativeDisplayList());
}
```

#### `RenderNode.getNativeDisplayList()` 方法
* 该方法获取的是native层的RootRenderNode对象
```java
long getNativeDisplayList() {
    if (!mValid) {
        throw new IllegalStateException("The display list is not valid.");
    }
    //mNativeRenderNode保存的就是native层的RootRenderNode对象，在RenderNode.adopt()方法种初始化
    return mNativeRenderNode;
}
```

### `JNI.drawRenderNode()` 函数
```cpp
static void android_view_DisplayListCanvas_drawRenderNode(JNIEnv* env,
        jobject clazz, jlong canvasPtr, jlong renderNodePtr) {
    Canvas* canvas = reinterpret_cast<Canvas*>(canvasPtr);
    RenderNode* renderNode = reinterpret_cast<RenderNode*>(renderNodePtr);
    //调用native层的canvas.drawRenderNode()函数，renderNode即native层的RootRenderNode对象
    canvas->drawRenderNode(renderNode);
}
```

### `DisplayListCanvas::drawRenderNode()` 函数
```cpp
void DisplayListCanvas::drawRenderNode(RenderNode* renderNode) {
    //将RenderNode封装成一个DrawRenderNodeOp对象
    DrawRenderNodeOp* op = new (alloc()) DrawRenderNodeOp(
            renderNode,
            *mState.currentTransform(),
            mState.clipIsSimple());
    //调用addRenderNodeOp()函数
    addRenderNodeOp(op);
}
```

### `DisplayListCanvas::addRenderNodeOp()` 函数
```cpp
size_t DisplayListCanvas::addRenderNodeOp(DrawRenderNodeOp* op) {
    int opIndex = addDrawOp(op);
#if !HWUI_NEW_OPS
    int childIndex = mDisplayList->addChild(op);

    // update the chunk's child indices
    DisplayList::Chunk& chunk = mDisplayList->chunks.back();
    chunk.endChildIndex = childIndex + 1;

    if (op->renderNode->stagingProperties().isProjectionReceiver()) {
        // use staging property, since recording on UI thread
        mDisplayList->projectionReceiveIndex = opIndex;
    }
#endif
    return opIndex;
}
```


### `RenderNode.end()` 方法
* 调用`DisplayListCanvas.finishRecording()`方法获得绘制好的DisplayList
* 调用native层的`setDisplayList()`方法，将绘制好的DisplayList保存到RootRenderNode中
```java
public void end(DisplayListCanvas canvas) {
    //返回一个DisplayList对象
    long displayList = canvas.finishRecording();
    nSetDisplayList(mNativeRenderNode, displayList);
    canvas.recycle();
    mValid = true;
}
```

#### `DisplayListCanvas.finishRecording()` 方法
```java
long finishRecording() {
    return nFinishRecording(mNativeCanvasWrapper);
}
```

#### `nFinishRecording()` 函数
调用natvie层对应的Canvas的finishRecording()函数
```cpp
static jlong android_view_DisplayListCanvas_finishRecording(JNIEnv* env,
        jobject clazz, jlong canvasPtr) {
    Canvas* canvas = reinterpret_cast<Canvas*>(canvasPtr);
    return reinterpret_cast<jlong>(canvas->finishRecording());
}
```

#### `DisplayListCanvas::finishRecording()` 函数
```cpp
DisplayList* DisplayListCanvas::finishRecording() {
    flushRestoreToCount();
    flushTranslate();

    mPaintMap.clear();
    mRegionMap.clear();
    mPathMap.clear();
    DisplayList* displayList = mDisplayList;
    mDisplayList = nullptr;
    mSkiaCanvasProxy.reset(nullptr);
    return displayList;
}
```


### `nSetDisplayList()` 函数
```cpp
static void android_view_RenderNode_setDisplayList(JNIEnv* env,
        jobject clazz, jlong renderNodePtr, jlong displayListPtr) {
    class RemovedObserver : public TreeObserver {
    public:
        virtual void onMaybeRemovedFromTree(RenderNode* node) override {
            maybeRemovedNodes.insert(sp<RenderNode>(node));
        }
        std::set< sp<RenderNode> > maybeRemovedNodes;
    };

    RenderNode* renderNode = reinterpret_cast<RenderNode*>(renderNodePtr);
    DisplayList* newData = reinterpret_cast<DisplayList*>(displayListPtr);
    RemovedObserver observer;
    renderNode->setStagingDisplayList(newData, &observer);
    for (auto& node : observer.maybeRemovedNodes) {
        if (node->hasParents()) continue;
        onRenderNodeRemoved(env, node.get());
    }
}
```


### `RenderNode::setStagingDisplayList()`函数
```cpp
void RenderNode::setStagingDisplayList(DisplayList* displayList, TreeObserver* observer) {
    mNeedsDisplayListSync = true;
    //清除mStagingDisplayList变量，并将新的displayList保存
    delete mStagingDisplayList;
    mStagingDisplayList = displayList;
    // If mParentCount == 0 we are the sole reference to this RenderNode,
    // so immediately free the old display list
    if (!mParentCount && !mStagingDisplayList) {
        deleteDisplayList(observer);
    }
}
```

---

## 软件绘制
1. 调用`Surface.lockCanvas()`方法获取一个用于绘制的`Canvas`
2. 调用`Canvas.translate()`方法将坐标系切换到控件自身的坐标系
3. 调用`View.draw()`方法将根控件绘制在Canvas上
4. 调用`Surface.unlockCanvasAndPost()`方法显示绘制后的内容

### `ViewRootImpl.drawSoftware()`方法
```java
private boolean drawSoftware(Surface surface, AttachInfo attachInfo, int xoff, int yoff,
        boolean scalingRequired, Rect dirty) {
    //定义绘制所需要的Canvas
    final Canvas canvas;
    try {
        //初始化脏区域的点坐标
        final int left = dirty.left;
        final int top = dirty.top;``
        final int right = dirty.right;
        final int bottom = dirty.bottom;
        //通过Surface.lockCanvas()方法获取一个以此surface为画布的Canvas
        canvas = mSurface.lockCanvas(dirty);

        // lockCanvas可能会改变脏区域大小，所以这里判断一下
        if (left != dirty.left || top != dirty.top || right != dirty.right
                || bottom != dirty.bottom) {
            attachInfo.mIgnoreDirtyState = true;
        }
        //设置Bitmap密度
        canvas.setDensity(mDensity);
    } catch (Surface.OutOfResourcesException e) {
        handleOutOfResourcesException(e);
        return false;
    } catch (IllegalArgumentException e) {
        //通知wm下次给个新的surface
        mLayoutRequested = true;
        return false;
    }

    try {
        //如果Bitmap有设置alpha的途径，需要清除
        if (!canvas.isOpaque() || yoff != 0 || xoff != 0) {
            canvas.drawColor(0, PorterDuff.Mode.CLEAR);
        }

        //绘制之前清空脏区域，这样如果在绘制过程中调用了View.invalidate()方法，可以重新计算脏区域
        dirty.setEmpty();
        mIsAnimating = false;
        mView.mPrivateFlags |= View.PFLAG_DRAWN;

        try {
            //使用Canvas进行第一次变换
            //变换的目的是使得其坐标系按照之前所计算的滚动量进行相应的滚动
            //随后绘制的内容都会在滚动后的新坐标系下进行
            canvas.translate(-xoff, -yoff);
            if (mTranslator != null) {
                mTranslator.translateCanvas(canvas);
            }
            //设置屏幕密度
            canvas.setScreenDensity(scalingRequired ? mNoncompatDensity : 0);
            attachInfo.mSetIgnoreDirtyState = false;
            //调用View.draw()方法在Canvas上绘制整个控件树
            mView.draw(canvas);

            drawAccessibilityFocusedDrawableIfNeeded(canvas);
        } finally {
            if (!attachInfo.mSetIgnoreDirtyState) {
                attachInfo.mIgnoreDirtyState = false;
            }
        }
    } finally {
        try {
            //调用Surface.unlockCanvasAndPost()方法显示绘制后的内容
            surface.unlockCanvasAndPost(canvas);
        } catch (IllegalArgumentException e) {
            mLayoutRequested = true;    // ask wm for a new surface next time.
            return false;
        }
    }
    return true;
}
```


## 控件绘制
**绘制控件树的步骤**
1. 绘制背景（调用`drawBackground()`方法，根据是否为实心控件选择绘制）
2. 保存Canvas图层
3. 绘制控件本身的内容（调用`onDraw()`方法）
4. 绘制子控件内容（调用`dispatchDraw()`方法，只有ViewGroup才会使用）
5. 绘制边界并恢复Canvas图层
6. 绘制前景（调用`onDrawForeground()`方法）

### `View.draw()` 方法
```java
public void draw(Canvas canvas) {
    final int privateFlags = mPrivateFlags;
    //检查privateFlags是否有PFLAG_DIRTY_OPAQUE标记判断是否为实心控件
    final boolean dirtyOpaque = (privateFlags & PFLAG_DIRTY_MASK) == PFLAG_DIRTY_OPAQUE &&
            (mAttachInfo == null || !mAttachInfo.mIgnoreDirtyState);
    mPrivateFlags = (privateFlags & ~PFLAG_DIRTY_MASK) | PFLAG_DRAWN;

    // Step 1, 绘制背景，实心控件会跳过该步骤
    int saveCount;
    if (!dirtyOpaque) {
        drawBackground(canvas);//调用drawBackground()方法
    }

    // skip step 2 & 5 if possible (common case)
    final int viewFlags = mViewFlags;
    boolean horizontalEdges = (viewFlags & FADING_EDGE_HORIZONTAL) != 0;
    boolean verticalEdges = (viewFlags & FADING_EDGE_VERTICAL) != 0;
    //如果控件不需要渐变边界，可以进入简便绘制流程
    if (!verticalEdges && !horizontalEdges) {
        // Step 3, 通过调用onDraw()方法绘制控件自身的内容
        if (!dirtyOpaque) onDraw(canvas);

        // Step 4, 通过调用dispatchDraw()方法绘制子控件，如果当前控件不是一个ViewGroup，此方法什么也不做
        dispatchDraw(canvas);

        // Overlay是内容的一部分，绘制在Forground的下面
        if (mOverlay != null && !mOverlay.isEmpty()) {
            mOverlay.getOverlayView().dispatchDraw(canvas);
        }

        // Step 6, 调用onDrawForeground()绘制前景、滚动条等
        onDrawForeground(canvas);
        return;
    }

    //接下来是完整的流程，出现的情况不多
    boolean drawTop = false;
    boolean drawBottom = false;
    boolean drawLeft = false;
    boolean drawRight = false;

    float topFadeStrength = 0.0f;
    float bottomFadeStrength = 0.0f;
    float leftFadeStrength = 0.0f;
    float rightFadeStrength = 0.0f;

    // Step 2, 保存Canvas图层
    int paddingLeft = mPaddingLeft;

    final boolean offsetRequired = isPaddingOffsetRequired();
    if (offsetRequired) {
        paddingLeft += getLeftPaddingOffset();
    }

    int left = mScrollX + paddingLeft;
    int right = left + mRight - mLeft - mPaddingRight - paddingLeft;
    int top = mScrollY + getFadeTop(offsetRequired);
    int bottom = top + getFadeHeight(offsetRequired);

    if (offsetRequired) {
        right += getRightPaddingOffset();
        bottom += getBottomPaddingOffset();
    }

    final ScrollabilityCache scrollabilityCache = mScrollCache;
    final float fadeHeight = scrollabilityCache.fadingEdgeLength;
    int length = (int) fadeHeight;

    // clip the fade length if top and bottom fades overlap
    // overlapping fades produce odd-looking artifacts
    if (verticalEdges && (top + length > bottom - length)) {
        length = (bottom - top) / 2;
    }

    // also clip horizontal fades if necessary
    if (horizontalEdges && (left + length > right - length)) {
        length = (right - left) / 2;
    }

    if (verticalEdges) {
        topFadeStrength = Math.max(0.0f, Math.min(1.0f, getTopFadingEdgeStrength()));
        drawTop = topFadeStrength * fadeHeight > 1.0f;
        bottomFadeStrength = Math.max(0.0f, Math.min(1.0f, getBottomFadingEdgeStrength()));
        drawBottom = bottomFadeStrength * fadeHeight > 1.0f;
    }

    if (horizontalEdges) {
        leftFadeStrength = Math.max(0.0f, Math.min(1.0f, getLeftFadingEdgeStrength()));
        drawLeft = leftFadeStrength * fadeHeight > 1.0f;
        rightFadeStrength = Math.max(0.0f, Math.min(1.0f, getRightFadingEdgeStrength()));
        drawRight = rightFadeStrength * fadeHeight > 1.0f;
    }

    saveCount = canvas.getSaveCount();

    int solidColor = getSolidColor();
    if (solidColor == 0) {
        final int flags = Canvas.HAS_ALPHA_LAYER_SAVE_FLAG;

        if (drawTop) {
            canvas.saveLayer(left, top, right, top + length, null, flags);
        }

        if (drawBottom) {
            canvas.saveLayer(left, bottom - length, right, bottom, null, flags);
        }

        if (drawLeft) {
            canvas.saveLayer(left, top, left + length, bottom, null, flags);
        }

        if (drawRight) {
            canvas.saveLayer(right - length, top, right, bottom, null, flags);
        }
    } else {
        scrollabilityCache.setFadeColor(solidColor);
    }

    // Step 3, 调用onDraw()方法绘制控件本身的内容
    if (!dirtyOpaque) onDraw(canvas);

    // Step 4, 调用dispatchDraw()方法绘制子控件内容，只有ViewGroup会使用
    dispatchDraw(canvas);

    // Step 5, 绘制褪色效果，并恢复图层
    final Paint p = scrollabilityCache.paint;
    final Matrix matrix = scrollabilityCache.matrix;
    final Shader fade = scrollabilityCache.shader;

    if (drawTop) {
        matrix.setScale(1, fadeHeight * topFadeStrength);
        matrix.postTranslate(left, top);
        fade.setLocalMatrix(matrix);
        p.setShader(fade);
        canvas.drawRect(left, top, right, top + length, p);
    }

    if (drawBottom) {
        matrix.setScale(1, fadeHeight * bottomFadeStrength);
        matrix.postRotate(180);
        matrix.postTranslate(left, bottom);
        fade.setLocalMatrix(matrix);
        p.setShader(fade);
        canvas.drawRect(left, bottom - length, right, bottom, p);
    }

    if (drawLeft) {
        matrix.setScale(1, fadeHeight * leftFadeStrength);
        matrix.postRotate(-90);
        matrix.postTranslate(left, top);
        fade.setLocalMatrix(matrix);
        p.setShader(fade);
        canvas.drawRect(left, top, left + length, bottom, p);
    }

    if (drawRight) {
        matrix.setScale(1, fadeHeight * rightFadeStrength);
        matrix.postRotate(90);
        matrix.postTranslate(right, top);
        fade.setLocalMatrix(matrix);
        p.setShader(fade);
        canvas.drawRect(right - length, top, right, bottom, p);
    }

    canvas.restoreToCount(saveCount);

    // Overlay是内容的一部分，绘制在Forground下面
    if (mOverlay != null && !mOverlay.isEmpty()) {
        mOverlay.getOverlayView().dispatchDraw(canvas);
    }

    // Step 6, 绘制前景、滚动条等
    onDrawForeground(canvas);
}
```

### `ViewGroup.dispatchDraw()`方法
* 该方法在View中是一个空实现，而ViewGroup实现来它
* 该方法是重绘从根控件延续到控件树中每一个子控件的重要纽带
```java
protected void dispatchDraw(Canvas canvas) {
    boolean usingRenderNodeProperties = canvas.isRecordingFor(mRenderNode);
    final int childrenCount = mChildrenCount;
    final View[] children = mChildren;
    int flags = mGroupFlags;

    //......动画相关

    int clipSaveCount = 0;
    //设置剪裁区域
    final boolean clipToPadding = (flags & CLIP_TO_PADDING_MASK) == CLIP_TO_PADDING_MASK;
    if (clipToPadding) {
        //首先调用Canvas.sava()方法保存Canvas状态，随后可以调用Canvas.restore()方法恢复到这个状态
        clipSaveCount = canvas.save();
        //调用Canvas.clipRect()方法，将给定区域之外的绘制进行裁剪
        canvas.clipRect(mScrollX + mPaddingLeft, mScrollY + mPaddingTop,
                mScrollX + mRight - mLeft - mPaddingRight,
                mScrollY + mBottom - mTop - mPaddingBottom);
    }

    //......动画相关

    boolean more = false;
    final long drawingTime = getDrawingTime();//获取时间戳，用于控件计算动画参数

    if (usingRenderNodeProperties) canvas.insertReorderBarrier();
    final int transientCount = mTransientIndices == null ? 0 : mTransientIndices.size();
    int transientIndex = transientCount != 0 ? 0 : -1;
    // Only use the preordered list if not HW accelerated, since the HW pipeline will do the
    // draw reordering internally
    final ArrayList<View> preorderedList = usingRenderNodeProperties
            ? null : buildOrderedChildList();
    final boolean customOrder = preorderedList == null
            && isChildrenDrawingOrderEnabled();
    //遍历绘制所有的子控件
    for (int i = 0; i < childrenCount; i++) {
        while (transientIndex >= 0 && mTransientIndices.get(transientIndex) == i) {
            final View transientChild = mTransientViews.get(transientIndex);
            if ((transientChild.mViewFlags & VISIBILITY_MASK) == VISIBLE ||
                    transientChild.getAnimation() != null) {
                //调用drawChild()方法绘制一个子控件
                more |= drawChild(canvas, transientChild, drawingTime);
            }
            transientIndex++;
            if (transientIndex >= transientCount) {
                transientIndex = -1;
            }
        }

        final int childIndex = getAndVerifyPreorderedIndex(childrenCount, i, customOrder);
        final View child = getAndVerifyPreorderedView(preorderedList, children, childIndex);
        if ((child.mViewFlags & VISIBILITY_MASK) == VISIBLE || child.getAnimation() != null) {
            more |= drawChild(canvas, child, drawingTime);
        }
    }
    while (transientIndex >= 0) {
        // there may be additional transient views after the normal views
        final View transientChild = mTransientViews.get(transientIndex);
        if ((transientChild.mViewFlags & VISIBILITY_MASK) == VISIBLE ||
                transientChild.getAnimation() != null) {
            more |= drawChild(canvas, transientChild, drawingTime);
        }
        transientIndex++;
        if (transientIndex >= transientCount) {
            break;
        }
    }
    if (preorderedList != null) preorderedList.clear();

    // Draw any disappearing views that have animations
    if (mDisappearingChildren != null) {
        final ArrayList<View> disappearingChildren = mDisappearingChildren;
        final int disappearingCount = disappearingChildren.size() - 1;
        // Go backwards -- we may delete as animations finish
        for (int i = disappearingCount; i >= 0; i--) {
            final View child = disappearingChildren.get(i);
            more |= drawChild(canvas, child, drawingTime);
        }
    }
    if (usingRenderNodeProperties) canvas.insertInorderBarrier();

    if (debugDraw()) {
        onDebugDraw(canvas);
    }

    //通过Canvas.restoreToCount()撤销（返回）之前所做的剪裁设置
    if (clipToPadding) {
        canvas.restoreToCount(clipSaveCount);
    }

    // mGroupFlags might have been updated by drawChild()
    flags = mGroupFlags;

    if ((flags & FLAG_INVALIDATE_REQUIRED) == FLAG_INVALIDATE_REQUIRED) {
        invalidate(true);
    }

    if ((flags & FLAG_ANIMATION_DONE) == 0 && (flags & FLAG_NOTIFY_ANIMATION_LISTENER) == 0 &&
            mLayoutAnimationController.isDone() && !more) {
        // We want to erase the drawing cache and notify the listener after the
        // next frame is drawn because one extra invalidate() is caused by
        // drawChild() after the animation is over
        mGroupFlags |= FLAG_NOTIFY_ANIMATION_LISTENER;
        final Runnable end = new Runnable() {
           @Override
           public void run() {
               notifyAnimationListener();
           }
        };
        post(end);
    }
}
```


### `ViewGroup.drawChild()`方法
仅仅是调用View.draw()的另一个重载的方法
```java
protected boolean drawChild(Canvas canvas, View child, long drawingTime) {
    return child.draw(canvas, this, drawingTime);
}
```


### `View.draw()`方法
```java
boolean draw(Canvas canvas, ViewGroup parent, long drawingTime) {
    final boolean hardwareAcceleratedCanvas = canvas.isHardwareAccelerated();
    /* If an attached view draws to a HW canvas, it may use its RenderNode + DisplayList.
     *
     * If a view is dettached, its DisplayList shouldn't exist. If the canvas isn't
     * HW accelerated, it can't handle drawing RenderNodes.
     */
    boolean drawingWithRenderNode = mAttachInfo != null
            && mAttachInfo.mHardwareAccelerated
            && hardwareAcceleratedCanvas;

    boolean more = false;
    final boolean childHasIdentityMatrix = hasIdentityMatrix();
    final int parentFlags = parent.mGroupFlags;

    if ((parentFlags & ViewGroup.FLAG_CLEAR_TRANSFORMATION) != 0) {
        parent.getChildTransformation().clear();
        parent.mGroupFlags &= ~ViewGroup.FLAG_CLEAR_TRANSFORMATION;
    }

    Transformation transformToApply = null;
    boolean concatMatrix = false;
    final boolean scalingRequired = mAttachInfo != null && mAttachInfo.mScalingRequired;
    final Animation a = getAnimation();
    if (a != null) {
        more = applyLegacyAnimation(parent, drawingTime, a, scalingRequired);
        concatMatrix = a.willChangeTransformationMatrix();
        if (concatMatrix) {
            mPrivateFlags3 |= PFLAG3_VIEW_IS_ANIMATING_TRANSFORM;
        }
        transformToApply = parent.getChildTransformation();
    } else {
        if ((mPrivateFlags3 & PFLAG3_VIEW_IS_ANIMATING_TRANSFORM) != 0) {
            // No longer animating: clear out old animation matrix
            mRenderNode.setAnimationMatrix(null);
            mPrivateFlags3 &= ~PFLAG3_VIEW_IS_ANIMATING_TRANSFORM;
        }
        if (!drawingWithRenderNode
                && (parentFlags & ViewGroup.FLAG_SUPPORT_STATIC_TRANSFORMATIONS) != 0) {
            final Transformation t = parent.getChildTransformation();
            final boolean hasTransform = parent.getChildStaticTransformation(this, t);
            if (hasTransform) {
                final int transformType = t.getTransformationType();
                transformToApply = transformType != Transformation.TYPE_IDENTITY ? t : null;
                concatMatrix = (transformType & Transformation.TYPE_MATRIX) != 0;
            }
        }
    }

    concatMatrix |= !childHasIdentityMatrix;

    // Sets the flag as early as possible to allow draw() implementations
    // to call invalidate() successfully when doing animations
    mPrivateFlags |= PFLAG_DRAWN;

    if (!concatMatrix &&
            (parentFlags & (ViewGroup.FLAG_SUPPORT_STATIC_TRANSFORMATIONS |
                    ViewGroup.FLAG_CLIP_CHILDREN)) == ViewGroup.FLAG_CLIP_CHILDREN &&
            canvas.quickReject(mLeft, mTop, mRight, mBottom, Canvas.EdgeType.BW) &&
            (mPrivateFlags & PFLAG_DRAW_ANIMATION) == 0) {
        mPrivateFlags2 |= PFLAG2_VIEW_QUICK_REJECTED;
        return more;
    }
    mPrivateFlags2 &= ~PFLAG2_VIEW_QUICK_REJECTED;

    if (hardwareAcceleratedCanvas) {
        // Clear INVALIDATED flag to allow invalidation to occur during rendering, but
        // retain the flag's value temporarily in the mRecreateDisplayList flag
        mRecreateDisplayList = (mPrivateFlags & PFLAG_INVALIDATED) != 0;
        mPrivateFlags &= ~PFLAG_INVALIDATED;
    }

    RenderNode renderNode = null;
    Bitmap cache = null;
    int layerType = getLayerType(); // TODO: signify cache state with just 'cache' local
    if (layerType == LAYER_TYPE_SOFTWARE || !drawingWithRenderNode) {
         if (layerType != LAYER_TYPE_NONE) {
             // If not drawing with RenderNode, treat HW layers as SW
             layerType = LAYER_TYPE_SOFTWARE;
             buildDrawingCache(true);
        }
        cache = getDrawingCache(true);
    }

    if (drawingWithRenderNode) {
        // Delay getting the display list until animation-driven alpha values are
        // set up and possibly passed on to the view
        renderNode = updateDisplayListIfDirty();
        if (!renderNode.isValid()) {
            // Uncommon, but possible. If a view is removed from the hierarchy during the call
            // to getDisplayList(), the display list will be marked invalid and we should not
            // try to use it again.
            renderNode = null;
            drawingWithRenderNode = false;
        }
    }

    int sx = 0;
    int sy = 0;
    if (!drawingWithRenderNode) {
        computeScroll();
        sx = mScrollX;
        sy = mScrollY;
    }

    final boolean drawingWithDrawingCache = cache != null && !drawingWithRenderNode;
    final boolean offsetForScroll = cache == null && !drawingWithRenderNode;

    int restoreTo = -1;
    if (!drawingWithRenderNode || transformToApply != null) {
        restoreTo = canvas.save();
    }
    if (offsetForScroll) {
        canvas.translate(mLeft - sx, mTop - sy);
    } else {
        if (!drawingWithRenderNode) {
            canvas.translate(mLeft, mTop);
        }
        if (scalingRequired) {
            if (drawingWithRenderNode) {
                // TODO: Might not need this if we put everything inside the DL
                restoreTo = canvas.save();
            }
            // mAttachInfo cannot be null, otherwise scalingRequired == false
            final float scale = 1.0f / mAttachInfo.mApplicationScale;
            canvas.scale(scale, scale);
        }
    }

    float alpha = drawingWithRenderNode ? 1 : (getAlpha() * getTransitionAlpha());
    if (transformToApply != null
            || alpha < 1
            || !hasIdentityMatrix()
            || (mPrivateFlags3 & PFLAG3_VIEW_IS_ANIMATING_ALPHA) != 0) {
        if (transformToApply != null || !childHasIdentityMatrix) {
            int transX = 0;
            int transY = 0;

            if (offsetForScroll) {
                transX = -sx;
                transY = -sy;
            }

            if (transformToApply != null) {
                if (concatMatrix) {
                    if (drawingWithRenderNode) {
                        renderNode.setAnimationMatrix(transformToApply.getMatrix());
                    } else {
                        // Undo the scroll translation, apply the transformation matrix,
                        // then redo the scroll translate to get the correct result.
                        canvas.translate(-transX, -transY);
                        canvas.concat(transformToApply.getMatrix());
                        canvas.translate(transX, transY);
                    }
                    parent.mGroupFlags |= ViewGroup.FLAG_CLEAR_TRANSFORMATION;
                }

                float transformAlpha = transformToApply.getAlpha();
                if (transformAlpha < 1) {
                    alpha *= transformAlpha;
                    parent.mGroupFlags |= ViewGroup.FLAG_CLEAR_TRANSFORMATION;
                }
            }

            if (!childHasIdentityMatrix && !drawingWithRenderNode) {
                canvas.translate(-transX, -transY);
                canvas.concat(getMatrix());
                canvas.translate(transX, transY);
            }
        }

        // Deal with alpha if it is or used to be <1
        if (alpha < 1 || (mPrivateFlags3 & PFLAG3_VIEW_IS_ANIMATING_ALPHA) != 0) {
            if (alpha < 1) {
                mPrivateFlags3 |= PFLAG3_VIEW_IS_ANIMATING_ALPHA;
            } else {
                mPrivateFlags3 &= ~PFLAG3_VIEW_IS_ANIMATING_ALPHA;
            }
            parent.mGroupFlags |= ViewGroup.FLAG_CLEAR_TRANSFORMATION;
            if (!drawingWithDrawingCache) {
                final int multipliedAlpha = (int) (255 * alpha);
                if (!onSetAlpha(multipliedAlpha)) {
                    if (drawingWithRenderNode) {
                        renderNode.setAlpha(alpha * getAlpha() * getTransitionAlpha());
                    } else if (layerType == LAYER_TYPE_NONE) {
                        canvas.saveLayerAlpha(sx, sy, sx + getWidth(), sy + getHeight(),
                                multipliedAlpha);
                    }
                } else {
                    // Alpha is handled by the child directly, clobber the layer's alpha
                    mPrivateFlags |= PFLAG_ALPHA_SET;
                }
            }
        }
    } else if ((mPrivateFlags & PFLAG_ALPHA_SET) == PFLAG_ALPHA_SET) {
        onSetAlpha(255);
        mPrivateFlags &= ~PFLAG_ALPHA_SET;
    }

    if (!drawingWithRenderNode) {
        // apply clips directly, since RenderNode won't do it for this draw
        if ((parentFlags & ViewGroup.FLAG_CLIP_CHILDREN) != 0 && cache == null) {
            if (offsetForScroll) {
                canvas.clipRect(sx, sy, sx + getWidth(), sy + getHeight());
            } else {
                if (!scalingRequired || cache == null) {
                    canvas.clipRect(0, 0, getWidth(), getHeight());
                } else {
                    canvas.clipRect(0, 0, cache.getWidth(), cache.getHeight());
                }
            }
        }

        if (mClipBounds != null) {
            // clip bounds ignore scroll
            canvas.clipRect(mClipBounds);
        }
    }

    if (!drawingWithDrawingCache) {
        if (drawingWithRenderNode) {
            mPrivateFlags &= ~PFLAG_DIRTY_MASK;
            ((DisplayListCanvas) canvas).drawRenderNode(renderNode);
        } else {
            // Fast path for layouts with no backgrounds
            if ((mPrivateFlags & PFLAG_SKIP_DRAW) == PFLAG_SKIP_DRAW) {
                mPrivateFlags &= ~PFLAG_DIRTY_MASK;
                dispatchDraw(canvas);
            } else {
                draw(canvas);
            }
        }
    } else if (cache != null) {
        mPrivateFlags &= ~PFLAG_DIRTY_MASK;
        if (layerType == LAYER_TYPE_NONE || mLayerPaint == null) {
            // no layer paint, use temporary paint to draw bitmap
            Paint cachePaint = parent.mCachePaint;
            if (cachePaint == null) {
                cachePaint = new Paint();
                cachePaint.setDither(false);
                parent.mCachePaint = cachePaint;
            }
            cachePaint.setAlpha((int) (alpha * 255));
            canvas.drawBitmap(cache, 0.0f, 0.0f, cachePaint);
        } else {
            // use layer paint to draw the bitmap, merging the two alphas, but also restore
            int layerPaintAlpha = mLayerPaint.getAlpha();
            if (alpha < 1) {
                mLayerPaint.setAlpha((int) (alpha * layerPaintAlpha));
            }
            canvas.drawBitmap(cache, 0.0f, 0.0f, mLayerPaint);
            if (alpha < 1) {
                mLayerPaint.setAlpha(layerPaintAlpha);
            }
        }
    }

    if (restoreTo >= 0) {
        canvas.restoreToCount(restoreTo);
    }

    if (a != null && !more) {
        if (!hardwareAcceleratedCanvas && !a.getFillAfter()) {
            onSetAlpha(255);
        }
        parent.finishAnimatingView(this, a);
    }

    if (more && hardwareAcceleratedCanvas) {
        if (a.hasAlpha() && (mPrivateFlags & PFLAG_ALPHA_SET) == PFLAG_ALPHA_SET) {
            // alpha animations should cause the child to recreate its display list
            invalidate(true);
        }
    }

    mRecreateDisplayList = false;

    return more;
}
```

### 参考
1. 深入理解Android卷3
2. luoshengyang博客------Android应用程序UI硬件加速渲染技术
http://blog.csdn.net/luoshengyang/article/details/45601143
http://blog.csdn.net/luoshengyang/article/details/45943255
