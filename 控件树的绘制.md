# 控件树的绘制
在开发Android自定义控件时，往往都需要重写View.onDraw()方法将内容绘制到一个给定的Canvas中。

# Canvas简介
* Canvas 是一个绘图工具类，其API提供了一系列绘图指令供开发者使用。
    * 绘制指令：由一系列名为`drawxxx()`的方法提供，用来实现实际的绘制行为。
      * 示例：绘制点、线、圆、方块等
    * 辅助指令：提供辅助功能的指令将会影响后续绘制指令的效果
      * 示例：设置变化、裁剪区域等
    * Canvas 还提供了`save()`和`restore()`方法用于撤销一部分辅助指令的效果
* Canvas 根据绘制加速模式的不同可以分为 **软件Canvas** 和 **硬件Canvas**

### Canvas的绘制目标
  * **软件Canvas:** 绘制目标就是建立在Surface上的位图Bitmap。
    * 通过`Surface.lockCanvas()`方法获得一个Canvas时会以Surface的内存创建一个Bbitmap，通过Canvas所绘制的内容会直接反映到Surface中
  * **硬件Canvas:** 绘制目标有两种。
    * **HardwareLayer:** GL Texture(纹理)，可以理解为硬件加速下的位图（Bitmap）
    * **DisplayList:** DisplayList不是一块Buffer,而是一个指令序列。DisplayList会将Canvas的绘制指令编译并优化为硬件绘制指令，并且可以在需要的时候将这些指令放回到一个HardwareLayer上。
  * DisplayList、Bitmap、HardwareLayer都可以理解为Canvas的画布


### Canvas的辅助指令
#### 1. 坐标变换
* `Canvas.translate()` 方法
  * 该方法即坐标变换指令，将矩形的位置和尺寸信息进行了分离，使得绘制矩形时的参数得到简化    

* 示例：当需要在（100,200）的位置绘制一个宽为50、高为100的矩形时。
  * 示例实现1（不使用辅助指令---坐标变换）
  ```java
  float x=100f, y=200f, w=50f, h=100f;
  mCanvas.drawRect(x, y, x+w, y+h, mPaint);
  ```

  * 示例实现2（坐标变换）
  ```java
  float x=100f, y=200f, w=50f, h=100f;
  //先使用translate()方法将后续绘制的坐标系原点变换到（x,y）的位置
  mCanvas.translate(x, y);
  //在新的坐标系下绘制矩形
  mCanvas.drawRect(0, 0, w, h, mPaint);
  ```


# 控件的脏区域
* 为来保证绘制的效率，控件树仅仅对需要重绘的区域进行绘制，这部分需要重绘的区域称为“脏区域”（DirtyArea）
* 当控件的内容发生变化需要重绘时，会调用`View.invalidate()`方法将需要重绘的区域沿着控件树提交给`ViewRootImpl`,并保存在`ViewRootImpl.mDiryt`全局变量中。
* 通过`scheduleTraversals()`方法引发一次遍历，使得`ViewRootImpl.mDirty`所描绘的区域得到重绘，避免不必要的开销
* `View.invalidate()`方法在回溯到`ViewRootImpl`的过程中会将沿途的控件标记为脏的，即将`View.mPrivateFlags`全局变量中添加`PFLAG_DIRTY`或`PFLAG_DIRTY_OPAQUE`。即有这两种标记的控件随后需要重绘。
  * `View.isOpaque()`方法，用于判断该控件是否为实心控件，（实心控件表示绘制内容会覆盖整个区域，无法看到该区域下的内容）
    * 如果是实心控件，标记为`PFLAG_DIRTY_OPAQUE`
      * 该标记的控件可以跳过背景绘制，反正也看不见
    * 非实心控件，标记为`PFLAG_DIRTY`
* 多次调用`invalidate()`方法会使得`ViewRootImpl`多次接收到脏区域的请求，`ViewRootImpl`会将这些脏区域累加到`mDirty`中，在随后的遍历种一次性地完成所有脏区域的重绘。
* `ViewRootImpl.mFullRedrawNeeded`为true时（窗口第一次绘制、或者窗口发生变化时）会使得在绘制之前将`mDirty`所描述的区域扩大到整个窗口，进而实现完整的重绘。


# 控件树绘制
在`ViewRootImpl.performTraversal()`的最后阶段调用了`ViewRootImpl.performDraw()`方法，该方法是绘制控件树的入口。

## 控件树绘制时序图
```puml
Title : 控件树绘制
ViewRootImpl -> ViewRootImpl : performDraw()
ViewRootImpl -> ViewRootImpl : draw()
Note right of ViewRootImpl : 硬件绘制
ViewRootImpl -> ThreadedRenderer : draw()

Note right of ViewRootImpl : 软件绘制
ViewRootImpl -> ViewRootImpl : drawSoftware()
ViewRootImpl -> Surface : lockCanvas()
Surface -> ViewRootImpl : 返回一个Canvas对象
ViewRootImpl -> Canvas : translate()
ViewRootImpl -> View : draw()
Note right of View : 控件绘制流程
View -> View : 1. drawBackground()
View -> Canvas : 2. saveLayer()
View -> View : 3. onDraw()
View -> View : 4. dispatchDraw()
View -> Canvas : 5. drawRect() & restoreToCount()
View -> View : 6. onDrawForeground()

ViewRootImpl -> Surface : unlockCanvasAndPost()



```

## `ViewRootImpl.performDraw()`方法
```java
private void performDraw() {
    //......
    final boolean fullRedrawNeeded = mFullRedrawNeeded;
    mFullRedrawNeeded = false;

    mIsDrawing = true;
    try {
        //调用ViewRootImpl.draw()方法进行实际的绘制工作
        draw(fullRedrawNeeded);
    } finally {
        mIsDrawing = false;
    }
    //......
    if (mReportNextDraw) {
        mReportNextDraw = false;
        //.......
        try {
            //通知WMS绘制已经完成
            mWindowSession.finishDrawing(mWindow);
        } catch (RemoteException e) {
        }
    }
}
```

## `ViewRootImpl.draw()`方法
```java
private void draw(boolean fullRedrawNeeded) {
    Surface surface = mSurface;
    //......

    /*计算mView在垂直方向的滚动量（ScrollY）
    在VisibleInsets存在的情况下，ViewRootImpl需要保证某个关键的控件是可见的

    例如当输入法弹出时，接收输入的TextView必须位于不被输入法遮挡的区域内，如果布局结果
    被挡，就需要根据VisibleInsets和它的相对位置计算一个滚动量，使整个控件树的绘制位置
    发生偏移，从而使TextView露出来。

    计算得到的滚动量被保存在mScroller中
    */
    scrollToRectOrFocus(null, false);

    if (mAttachInfo.mViewScrollChanged) {
        mAttachInfo.mViewScrollChanged = false;
        mAttachInfo.mTreeObserver.dispatchOnScrollChanged();
    }

    //为了滚动显得不那么突兀，产生一个动画效果
    boolean animating = mScroller != null && mScroller.computeScrollOffset();
    final int curScrollY;
    if (animating) {//动画正在执行，采用mScroller所计算的滚动量
        curScrollY = mScroller.getCurrY();
    } else {//动画已经结束，使用scrollToRectOrFocus()计算的滚动量
        curScrollY = mScrollY;
    }
    //如果新计算的滚动量与上次绘制的滚动量不同，则必须进行完整的绘制
    //因为发生滚动时，整个画面都需要更新，设置fullRedrawNeeded为true
    if (mCurScrollY != curScrollY) {
        mCurScrollY = curScrollY;
        fullRedrawNeeded = true;
        //如果view需要自己渲染，则将滚动量回调给它
        if (mView instanceof RootViewSurfaceTaker) {
            ((RootViewSurfaceTaker) mView).onRootViewScrollYChanged(mCurScrollY);
        }
    }
    //......
    //需要全部更新，重新设置dirty区域为整个窗口
    if (fullRedrawNeeded) {
        mAttachInfo.mIgnoreDirtyState = true;
        dirty.set(0, 0, (int) (mWidth * appScale + 0.5f), (int) (mHeight * appScale + 0.5f));
    }
    //......
    if (!dirty.isEmpty() || mIsAnimating || accessibilityFocusDirty) {
        //硬件加速渲染是打开且有效的
        if (mAttachInfo.mHardwareRenderer != null && mAttachInfo.mHardwareRenderer.isEnabled()) {
            //......
            //通过硬件加速绘制调用ThreadedRenderer.draw()方法
            mAttachInfo.mHardwareRenderer.draw(mView, mAttachInfo, this);
        } else {//没有硬件加速
            //硬件加速绘制存在且请求过，但是没有打开，尝试重新初始化,重新遍历全部更新
            //......
            //调用drawSoftware()方法进行软件绘制
            if (!drawSoftware(surface, mAttachInfo, xOffset, yOffset, scalingRequired, dirty)) {
                return;
            }
        }
    }

    //如果mScroller仍然在动画过程中，则立即安排下一次重绘，
    if (animating) {
        //设置mFullRedrawNeeded为true，表示整个窗口需要全部更新
        mFullRedrawNeeded = true;
        //调用scheduleTraversals()遍历
        scheduleTraversals();
    }
}
```

## 软件绘制
1. 调用`Surface.lockCanvas()`方法获取一个用于绘制的`Canvas`
2. 调用`Canvas.translate()`方法将坐标系切换到控件自身的坐标系
3. 调用`View.draw()`方法将根控件绘制在Canvas上
4. 调用`Surface.unlockCanvasAndPost()`方法显示绘制后的内容

### `ViewRootImpl.drawSoftware()`方法
```java
private boolean drawSoftware(Surface surface, AttachInfo attachInfo, int xoff, int yoff,
        boolean scalingRequired, Rect dirty) {
    //定义绘制所需要的Canvas
    final Canvas canvas;
    try {
        //初始化脏区域的点坐标
        final int left = dirty.left;
        final int top = dirty.top;``
        final int right = dirty.right;
        final int bottom = dirty.bottom;
        //通过Surface.lockCanvas()方法获取一个以此surface为画布的Canvas
        canvas = mSurface.lockCanvas(dirty);

        // lockCanvas可能会改变脏区域大小，所以这里判断一下
        if (left != dirty.left || top != dirty.top || right != dirty.right
                || bottom != dirty.bottom) {
            attachInfo.mIgnoreDirtyState = true;
        }
        //设置Bitmap密度
        canvas.setDensity(mDensity);
    } catch (Surface.OutOfResourcesException e) {
        handleOutOfResourcesException(e);
        return false;
    } catch (IllegalArgumentException e) {
        //通知wm下次给个新的surface
        mLayoutRequested = true;
        return false;
    }

    try {
        //如果Bitmap有设置alpha的途径，需要清除
        if (!canvas.isOpaque() || yoff != 0 || xoff != 0) {
            canvas.drawColor(0, PorterDuff.Mode.CLEAR);
        }

        //绘制之前清空脏区域，这样如果在绘制过程中调用了View.invalidate()方法，可以重新计算脏区域
        dirty.setEmpty();
        mIsAnimating = false;
        mView.mPrivateFlags |= View.PFLAG_DRAWN;

        try {
            //使用Canvas进行第一次变换
            //变换的目的是使得其坐标系按照之前所计算的滚动量进行相应的滚动
            //随后绘制的内容都会在滚动后的新坐标系下进行
            canvas.translate(-xoff, -yoff);
            if (mTranslator != null) {
                mTranslator.translateCanvas(canvas);
            }
            //设置屏幕密度
            canvas.setScreenDensity(scalingRequired ? mNoncompatDensity : 0);
            attachInfo.mSetIgnoreDirtyState = false;
            //调用View.draw()方法在Canvas上绘制整个控件树
            mView.draw(canvas);

            drawAccessibilityFocusedDrawableIfNeeded(canvas);
        } finally {
            if (!attachInfo.mSetIgnoreDirtyState) {
                attachInfo.mIgnoreDirtyState = false;
            }
        }
    } finally {
        try {
            //调用Surface.unlockCanvasAndPost()方法显示绘制后的内容
            surface.unlockCanvasAndPost(canvas);
        } catch (IllegalArgumentException e) {
            mLayoutRequested = true;    // ask wm for a new surface next time.
            return false;
        }
    }
    return true;
}
```


## 控件绘制
**绘制控件树的步骤**
1. 绘制背景（调用`drawBackground()`方法，根据是否为实心控件选择绘制）
2. 保存Canvas图层
3. 绘制控件本身的内容（调用`onDraw()`方法）
4. 绘制子控件内容（调用`dispatchDraw()`方法，只有ViewGroup才会使用）
5. 绘制边界并恢复Canvas图层
6. 绘制前景（调用`onDrawForeground()`方法）

### `View.draw()` 方法
```java
public void draw(Canvas canvas) {
    final int privateFlags = mPrivateFlags;
    //检查privateFlags是否有PFLAG_DIRTY_OPAQUE标记判断是否为实心控件
    final boolean dirtyOpaque = (privateFlags & PFLAG_DIRTY_MASK) == PFLAG_DIRTY_OPAQUE &&
            (mAttachInfo == null || !mAttachInfo.mIgnoreDirtyState);
    mPrivateFlags = (privateFlags & ~PFLAG_DIRTY_MASK) | PFLAG_DRAWN;

    // Step 1, 绘制背景，实心控件会跳过该步骤
    int saveCount;
    if (!dirtyOpaque) {
        drawBackground(canvas);//调用drawBackground()方法
    }

    // skip step 2 & 5 if possible (common case)
    final int viewFlags = mViewFlags;
    boolean horizontalEdges = (viewFlags & FADING_EDGE_HORIZONTAL) != 0;
    boolean verticalEdges = (viewFlags & FADING_EDGE_VERTICAL) != 0;
    //如果控件不需要渐变边界，可以进入简便绘制流程
    if (!verticalEdges && !horizontalEdges) {
        // Step 3, 通过调用onDraw()方法绘制控件自身的内容
        if (!dirtyOpaque) onDraw(canvas);

        // Step 4, 通过调用dispatchDraw()方法绘制子控件，如果当前控件不是一个ViewGroup，此方法什么也不做
        dispatchDraw(canvas);

        // Overlay是内容的一部分，绘制在Forground的下面
        if (mOverlay != null && !mOverlay.isEmpty()) {
            mOverlay.getOverlayView().dispatchDraw(canvas);
        }

        // Step 6, 调用onDrawForeground()绘制前景、滚动条等
        onDrawForeground(canvas);
        return;
    }

    //接下来是完整的流程，出现的情况不多
    boolean drawTop = false;
    boolean drawBottom = false;
    boolean drawLeft = false;
    boolean drawRight = false;

    float topFadeStrength = 0.0f;
    float bottomFadeStrength = 0.0f;
    float leftFadeStrength = 0.0f;
    float rightFadeStrength = 0.0f;

    // Step 2, 保存Canvas图层
    int paddingLeft = mPaddingLeft;

    final boolean offsetRequired = isPaddingOffsetRequired();
    if (offsetRequired) {
        paddingLeft += getLeftPaddingOffset();
    }

    int left = mScrollX + paddingLeft;
    int right = left + mRight - mLeft - mPaddingRight - paddingLeft;
    int top = mScrollY + getFadeTop(offsetRequired);
    int bottom = top + getFadeHeight(offsetRequired);

    if (offsetRequired) {
        right += getRightPaddingOffset();
        bottom += getBottomPaddingOffset();
    }

    final ScrollabilityCache scrollabilityCache = mScrollCache;
    final float fadeHeight = scrollabilityCache.fadingEdgeLength;
    int length = (int) fadeHeight;

    // clip the fade length if top and bottom fades overlap
    // overlapping fades produce odd-looking artifacts
    if (verticalEdges && (top + length > bottom - length)) {
        length = (bottom - top) / 2;
    }

    // also clip horizontal fades if necessary
    if (horizontalEdges && (left + length > right - length)) {
        length = (right - left) / 2;
    }

    if (verticalEdges) {
        topFadeStrength = Math.max(0.0f, Math.min(1.0f, getTopFadingEdgeStrength()));
        drawTop = topFadeStrength * fadeHeight > 1.0f;
        bottomFadeStrength = Math.max(0.0f, Math.min(1.0f, getBottomFadingEdgeStrength()));
        drawBottom = bottomFadeStrength * fadeHeight > 1.0f;
    }

    if (horizontalEdges) {
        leftFadeStrength = Math.max(0.0f, Math.min(1.0f, getLeftFadingEdgeStrength()));
        drawLeft = leftFadeStrength * fadeHeight > 1.0f;
        rightFadeStrength = Math.max(0.0f, Math.min(1.0f, getRightFadingEdgeStrength()));
        drawRight = rightFadeStrength * fadeHeight > 1.0f;
    }

    saveCount = canvas.getSaveCount();

    int solidColor = getSolidColor();
    if (solidColor == 0) {
        final int flags = Canvas.HAS_ALPHA_LAYER_SAVE_FLAG;

        if (drawTop) {
            canvas.saveLayer(left, top, right, top + length, null, flags);
        }

        if (drawBottom) {
            canvas.saveLayer(left, bottom - length, right, bottom, null, flags);
        }

        if (drawLeft) {
            canvas.saveLayer(left, top, left + length, bottom, null, flags);
        }

        if (drawRight) {
            canvas.saveLayer(right - length, top, right, bottom, null, flags);
        }
    } else {
        scrollabilityCache.setFadeColor(solidColor);
    }

    // Step 3, 调用onDraw()方法绘制控件本身的内容
    if (!dirtyOpaque) onDraw(canvas);

    // Step 4, 调用dispatchDraw()方法绘制子控件内容，只有ViewGroup会使用
    dispatchDraw(canvas);

    // Step 5, 绘制褪色效果，并恢复图层
    final Paint p = scrollabilityCache.paint;
    final Matrix matrix = scrollabilityCache.matrix;
    final Shader fade = scrollabilityCache.shader;

    if (drawTop) {
        matrix.setScale(1, fadeHeight * topFadeStrength);
        matrix.postTranslate(left, top);
        fade.setLocalMatrix(matrix);
        p.setShader(fade);
        canvas.drawRect(left, top, right, top + length, p);
    }

    if (drawBottom) {
        matrix.setScale(1, fadeHeight * bottomFadeStrength);
        matrix.postRotate(180);
        matrix.postTranslate(left, bottom);
        fade.setLocalMatrix(matrix);
        p.setShader(fade);
        canvas.drawRect(left, bottom - length, right, bottom, p);
    }

    if (drawLeft) {
        matrix.setScale(1, fadeHeight * leftFadeStrength);
        matrix.postRotate(-90);
        matrix.postTranslate(left, top);
        fade.setLocalMatrix(matrix);
        p.setShader(fade);
        canvas.drawRect(left, top, left + length, bottom, p);
    }

    if (drawRight) {
        matrix.setScale(1, fadeHeight * rightFadeStrength);
        matrix.postRotate(90);
        matrix.postTranslate(right, top);
        fade.setLocalMatrix(matrix);
        p.setShader(fade);
        canvas.drawRect(right - length, top, right, bottom, p);
    }

    canvas.restoreToCount(saveCount);

    // Overlay是内容的一部分，绘制在Forground下面
    if (mOverlay != null && !mOverlay.isEmpty()) {
        mOverlay.getOverlayView().dispatchDraw(canvas);
    }

    // Step 6, 绘制前景、滚动条等
    onDrawForeground(canvas);
}
```

### `ViewGroup.dispatchDraw()`方法
* 该方法在View中是一个空实现，而ViewGroup实现来它
* 该方法是重绘从根控件延续到控件树中每一个子控件的重要纽带
```java
protected void dispatchDraw(Canvas canvas) {
    boolean usingRenderNodeProperties = canvas.isRecordingFor(mRenderNode);
    final int childrenCount = mChildrenCount;
    final View[] children = mChildren;
    int flags = mGroupFlags;

    //......动画相关

    int clipSaveCount = 0;
    //设置剪裁区域
    final boolean clipToPadding = (flags & CLIP_TO_PADDING_MASK) == CLIP_TO_PADDING_MASK;
    if (clipToPadding) {
        //首先调用Canvas.sava()方法保存Canvas状态，随后可以调用Canvas.restore()方法恢复到这个状态
        clipSaveCount = canvas.save();
        //调用Canvas.clipRect()方法，将给定区域之外的绘制进行裁剪
        canvas.clipRect(mScrollX + mPaddingLeft, mScrollY + mPaddingTop,
                mScrollX + mRight - mLeft - mPaddingRight,
                mScrollY + mBottom - mTop - mPaddingBottom);
    }

    //......动画相关

    boolean more = false;
    final long drawingTime = getDrawingTime();//获取时间戳，用于控件计算动画参数

    if (usingRenderNodeProperties) canvas.insertReorderBarrier();
    final int transientCount = mTransientIndices == null ? 0 : mTransientIndices.size();
    int transientIndex = transientCount != 0 ? 0 : -1;
    // Only use the preordered list if not HW accelerated, since the HW pipeline will do the
    // draw reordering internally
    final ArrayList<View> preorderedList = usingRenderNodeProperties
            ? null : buildOrderedChildList();
    final boolean customOrder = preorderedList == null
            && isChildrenDrawingOrderEnabled();
    //遍历绘制所有的子控件
    for (int i = 0; i < childrenCount; i++) {
        while (transientIndex >= 0 && mTransientIndices.get(transientIndex) == i) {
            final View transientChild = mTransientViews.get(transientIndex);
            if ((transientChild.mViewFlags & VISIBILITY_MASK) == VISIBLE ||
                    transientChild.getAnimation() != null) {
                //调用drawChild()方法绘制一个子控件
                more |= drawChild(canvas, transientChild, drawingTime);
            }
            transientIndex++;
            if (transientIndex >= transientCount) {
                transientIndex = -1;
            }
        }

        final int childIndex = getAndVerifyPreorderedIndex(childrenCount, i, customOrder);
        final View child = getAndVerifyPreorderedView(preorderedList, children, childIndex);
        if ((child.mViewFlags & VISIBILITY_MASK) == VISIBLE || child.getAnimation() != null) {
            more |= drawChild(canvas, child, drawingTime);
        }
    }
    while (transientIndex >= 0) {
        // there may be additional transient views after the normal views
        final View transientChild = mTransientViews.get(transientIndex);
        if ((transientChild.mViewFlags & VISIBILITY_MASK) == VISIBLE ||
                transientChild.getAnimation() != null) {
            more |= drawChild(canvas, transientChild, drawingTime);
        }
        transientIndex++;
        if (transientIndex >= transientCount) {
            break;
        }
    }
    if (preorderedList != null) preorderedList.clear();

    // Draw any disappearing views that have animations
    if (mDisappearingChildren != null) {
        final ArrayList<View> disappearingChildren = mDisappearingChildren;
        final int disappearingCount = disappearingChildren.size() - 1;
        // Go backwards -- we may delete as animations finish
        for (int i = disappearingCount; i >= 0; i--) {
            final View child = disappearingChildren.get(i);
            more |= drawChild(canvas, child, drawingTime);
        }
    }
    if (usingRenderNodeProperties) canvas.insertInorderBarrier();

    if (debugDraw()) {
        onDebugDraw(canvas);
    }

    //通过Canvas.restoreToCount()撤销（返回）之前所做的剪裁设置
    if (clipToPadding) {
        canvas.restoreToCount(clipSaveCount);
    }

    // mGroupFlags might have been updated by drawChild()
    flags = mGroupFlags;

    if ((flags & FLAG_INVALIDATE_REQUIRED) == FLAG_INVALIDATE_REQUIRED) {
        invalidate(true);
    }

    if ((flags & FLAG_ANIMATION_DONE) == 0 && (flags & FLAG_NOTIFY_ANIMATION_LISTENER) == 0 &&
            mLayoutAnimationController.isDone() && !more) {
        // We want to erase the drawing cache and notify the listener after the
        // next frame is drawn because one extra invalidate() is caused by
        // drawChild() after the animation is over
        mGroupFlags |= FLAG_NOTIFY_ANIMATION_LISTENER;
        final Runnable end = new Runnable() {
           @Override
           public void run() {
               notifyAnimationListener();
           }
        };
        post(end);
    }
}
```
